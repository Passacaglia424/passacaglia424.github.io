<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>先手必胜？策梅洛定理的探讨</title>
      <link href="/2022/02/14/%E7%AD%96%E6%A2%85%E6%B4%9B%E5%AE%9A%E7%90%86%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2022/02/14/%E7%AD%96%E6%A2%85%E6%B4%9B%E5%AE%9A%E7%90%86%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h3>1.关于定理</h3>笔者作为一个棋类，尤其是象棋的爱好者，特别喜欢钻研下棋的一些套路。然而，随着计算机算力的提高，AI技术的发展，人类逐渐开始下不过人工智能。尚在2006年，象棋特级大师许银川还能勉强战胜当时比较强大的电脑浪潮天梭，之后战胜电脑就逐渐成了绝唱，发展到现在，即使运行在普通PC机上的《象棋名手》软件，也不是象棋世界冠军可以抗衡的。2017年，柯洁0:3负于阿尔法狗，也标志者围棋，这一棋类智力之冠的胜利也归人工智能所有。那么，我们可以很自然地想到，会不会有一天,不需要开下，只要棋一摆好，双方就能知道哪一方胜利呢?<p>这在理论上是可行的。<strong>策梅略定理</strong>（Zermelo’s theorem）是博弈论的一条定理,以恩斯特●策梅洛命名。定理表示在二人的有限游戏中，如果双方皆拥有完全的资讯，并且运气因素并不牵涉在游戏中，那先行或后行者当中必有一方有必胜&#x2F;必不败的策略（注意，也包括平局)。策梅洛定理的论文于1913年以德文发表。</p><p>策梅洛定理仅在双人游戏中有效，在三人及以上的多人游戏中胜负仍是不确定的。定理的具体表现形式，满足<strong>条件</strong>：</p><ol><li>双方依次行动</li><li>有限步，不会出现可以一直重复某种循环的状态</li><li>信息完备，双方均知道先前的步骤且没有隐藏的机制</li><li>仅有赢、输、平局三种结局</li></ol><p>在满足以上四种条件的情况下，只会出现以下<strong>情况</strong>之一</p><ol><li>先走方有必胜的走法</li><li>两者的最优策略会导向平局</li><li>后走方有必胜的走法</li></ol><p>满足情况3：“后走方有必胜的走法”，需要规则内不能有停止行动的选项，否则先手方的最优策略是停一回合，成为实际上的后手方，那么此时后手方的最优解也是停一回合。如果能无限停止，将不满足条件2，如果不能无限停止，将导向情况2。</p><p>对于<strong>策梅洛定理的证明</strong>，可以采用数学归纳法证明。假设结束所需的回合数n。n&#x3D;1,即一步就能游戏结束，那么一定会导致先手必胜&#x2F;负&#x2F;和的局面。现在对于任何一个n&gt;1的值，行动后将转换为一个n-1时的情况，而这时的结果是已知的。因为对于此时先手方行动的情况，必然是以下三种互斥的情况之一：</p><ol><li>存在行动方案使得之后的状态为先手方有必胜策略，那么此时先手有必胜策略；</li><li>所有的行动方案都使得之后的状态为后手方有必胜策略，那么此时后手方有必胜策略；</li><li>不存在行动方案使得之后的状态为先手方有必胜策略，且存在行动方案使得之后的状态为双方有不败的策略，那么此时有双方不败的策略。</li></ol><p>编程上，如果有类似状况，一般使用记忆化搜索的方式应用。      </p><h3>2.已得到验证的游戏</h3><h4>经典井字棋</h4>经典的3x3井字棋就是一个典型的双方不败游戏。为了增加点代入感，我们先手用○，后手用×来表示吧。○的第一步行动为走正中，此时×必须走角落，否则○将必胜：因为○第二步走对位的角落，那么×在堵的过程中会出现堵不上的情况：<p><img src="https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/20220214233346.png" alt="井字棋图"></p><p>由于井字棋上下左右对称，×走四个位置都会触发以上情况。<br>另一种情况，如果第二步×走角落，那么无论○下一步怎么走，×都可以阻止其连成三个，直至下满，双方和棋。</p><h4>无禁手规则的五子棋</h4><blockquote><p>禁手：五子棋术语，指对局中禁止先行一方(黑方)使用的战术，具体包括黑方一子落下时同时形成双活三、双四或长连等三种棋形。禁手只对黑方有效，白方无禁手。黑方禁手的位置称为禁手点。</p></blockquote><p>五子棋在很早的时候，就已经有前人研究出了无禁手规则下先手必胜的情况。对于白棋的应对不同，开局可以分为蒲月、寒星、新月等，但是所有的开局，无论白棋如何防备，只要黑方不下错，都不能阻止黑棋胜利。因此，五子棋赛场上都对先手方有很大的限制。日常下棋达不到那么高的水平，但是一般也能感觉到黑棋优势较大。<br>五子棋执黑必胜的变招相当多，读者感兴趣可以自行了解，这里只列举其中的蒲月开局：<br><img src="https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/20220215000533.png" alt="20220215000533"><br>黑棋正中开局，白棋下在斜线，黑棋再下在3的位置，对此，白棋可以有很多种应对方法：<br><img src="https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/20220215001207.png" alt="20220215001207"><br>其中最后一幅图为白棋最强防守，但是黑方可以选择：<br><img src="https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/20220215001454.png" alt="20220215001454"><br>后招可以参考<a href="https://wenku.so.com/d/df91d9b58a3c207002ada61806fee442%E3%80%82">https://wenku.so.com/d/df91d9b58a3c207002ada61806fee442。</a></p><h4>双人取物游戏</h4>地上摆放了80个物品，每人每次可以取1至4个，双方轮流取物，取到最后一个者胜利，那么某一方是否有必胜策略？<p>后手方必胜。先手方取X个时，后手方取5-X个，这样每个回合两人加起来都为五个，而5是80的公约数。这类游戏可以拓展到<strong>一般形式</strong>：地上摆放了X个物品，每人每次可以取Y至Z个，取到最后一个者胜利。那么如果X是Y+Z的公倍数，后手方必胜，每次先手方取s个时，后手方取Y+Z-s个。如果X不是Y+Z的公倍数，先手方必胜，先手方先取X除以Y+Z的余数个，转换为前一情况的后手方，执行前一情况的必胜策略。如果做过编程类题目，应该对此不陌生。</p><h4>WU游戏</h4>确切地说，这个并没有被证实，只是我对此比较感兴趣，想找出有没有一方必胜的方式（按照策梅洛定理，应该是有的）。灵感来自于侯世达著的《哥德尔、艾舍尔、巴赫——集异壁之大成》一书中的WU谜题。<p>设置游戏规则如下：<br>初始给定”WUWU”字符串，两人参与，双方轮流设计一条规则。<br>规则设置方式：<br>1.假定α,β分别为一至三个任意字母。<br>2.条件项选其一：如果字符串中有α&#x2F;以α开头&#x2F;以α结尾。<br>执行项选其一：可以将其删除并在原位置添加β&#x2F;在串尾添加β&#x2F;在串首添加β。<br>每设定一条规则，将会按顺序执行所有的规则直至字符串不再发生改变，转移到下一个人设定。如果设定规则与之前某规则冲突，则删除之前的规则。不能设置无限递归规则。<br>胜利条件：清空字符串者立即获得胜利，连续两回合将字符串变成同样的全相同字母者获得胜利。</p><h3>3.定理的思考</h3><h4>策梅略定理对积分制是否有效?</h4>由于定理的前提条件是结局仅有胜、负、和三种可能，那么把积分设定为：分高者胜，双方同分则平局。那么，定理仍然是有效的。如果规则机制中会允许执行某些步骤会导致暂时导向分数降低，但是一定步骤后会收束为分数比常规增加更高的情况，按数学归纳法，这类情况可以成为一个集合，从而将其看做一个步骤，这个步骤集由于更优会取代其它的步骤集合。许多游戏也可以视为积分制，比如象棋设置胜利为10000分，开局双方0分，每下一步都为局势评分，就像现在的象棋打分软件，一些弃子攻杀的步骤也会先打低分再打高分。<h4>策梅洛定理对二人以上博弈为什么无效？</h4>假设三人A、B、C游戏，游戏设定为一方胜利另两方败，或者三人平局。如果按A、B、C的顺序依次执行，如果A有必胜策略，那么把B、C的行动组合，将其看做一个两次行动的对手，从而变成两人形式，似乎可行？但是如果A只有必和策略，那么情况就不太确定了，作为理性人B、C采取的对自己的最优策略，但是由于只有一个胜利者，这个策略合起来不一定是最优的，可能不会导致趋向于平局。其实我也不太确定，以上只是一点推论，不一定正确。<h4>证明结论成立到找出结果需要多少努力？</h4>对于一些简单游戏来说不难，但是对目前的“大棋”很难，按对局的变化数来说，围棋的棋盘就有2^361种可能(再减去气中有子的情况)，再加上每一步的可能性，目前的算力要花费数十亿年计算。穷举既然不可行，那么只能寄托于数学家、科学家们、围棋大师们能不能找到合适的算法了。<p>对这个定理来说，虽然我们或许目前不能找到一方必胜或必和的方式是怎样的，但是我们能证明它存在也是有意义的，或许日后会有应用前景。就像密码学中的零知识证明，A方在不透露任何知识的情况下让B方相信A掌握了这个知识，也有其应用场景，如数字签名。</p><p>策梅洛定理属于博弈论的其中一个环节，笔者虽然没有系统学过博弈论的课程，但是对博弈论有一定的兴趣和研究。如果读者也对这些感兴趣的话，维基百科上有较为详尽的博弈论内容：</p><p><img src="https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/20220214233837.png" alt="维基百科图"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定理 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的常用指令</title>
      <link href="/2022/02/13/Git%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/02/13/Git%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>最近想系统学一下Git，而不仅仅是简单的拉取和推送。然而我查阅Git的官方文档的时候，因为懒得看英文，网页设置为谷歌自动翻译，但是”git”在英文中是混账、饭桶的意思，所以出现了啼笑生非的一幕：<br><img src="https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/20220216142916.png" alt="20220216142916"><br>因此，为了使用方便（头不笑掉），这里把git常用的一些命令记录下来。建议使用最新版本。</p><blockquote><p>官方文档参见<a href="https://git-scm.com/docs">Git Reference</a>，内容完整，不过可读性一般。</p></blockquote><h3 id="常见词汇"><a href="#常见词汇" class="headerlink" title="常见词汇"></a>常见词汇</h3><p><strong>repo</strong>:repository的简称，指代本地或远程仓库。<br><strong>工作树</strong>:一般指实际操作的目录，目录结构是树型的。<br><strong>索引(index)</strong>:也叫暂存区，逻辑结构上位于工作树和版本库之间。工作树状态提交到索引，再由索引数据添加到版本库。一般来说，当前在目录上进行改动视为在暂存区更改，只有commit后才会成为新的版本。<br><strong>分支(branch)</strong>:进行版本控制时可以有多个不同分支，互不影响，可以有多种修改。主分支为”master”。<br><strong>HEAD</strong>:指向现在使用的分支的最后一次更新，在&#x2F;git&#x2F;HEAD。<br><strong>版本</strong>：每次提交作为一个版本，每个版本都会有自己的版本信息。可视为分支上的结点。<br><strong>commit</strong>:提交，一次提交生成一个版本。</p><h3 id="定义的环境变量"><a href="#定义的环境变量" class="headerlink" title="定义的环境变量"></a>定义的环境变量</h3><p><strong>HOME</strong>:git的全局配置位置。<br><strong>GIT_ALTERNATE_OBJECT_DIRECTORIES</strong>：告诉 Git 到哪里去找不在 GIT_OBJECT_DIRECTORY 目录中的对象。 如果你有很多项目有相同内容的大文件，这个可以用来避免存储过多备份。<br><strong>GIT_DIR</strong>：生成.git的工作目录，如果没有设置， Git 会按照目录树逐层向上查找 .git 目录，直到到达 ~ 或 &#x2F;。<br><strong>GIT_EDITOR</strong>：用户需要编辑文本时git使用的编辑器。<br><strong>GIT_EXEC_PATH</strong>:git寻找根据此路径找子程序，git –exec-path查看。<br><strong>GIT_HTTP_LOW_SPEED_LIMIT</strong>：若git网络操作在网速低于GIT_HTTP_LOW_SPEED_LIMIT字节&#x2F;秒，并且持续 GIT_HTTP_LOW_SPEED_TIME 秒以上的时间，Git 会终止这个操作。<br><strong>GIT_ICASE_PATHSPECS</strong>:让所有的路径规范忽略大小写。<br><strong>GIT_INDEX_FILE</strong>：索引文件的路径。<br><strong>GIT_NOGLOB_PATHSPECS</strong>：若设置为1，通配符将仅作为字符匹配，如*.c只匹配名为*.c的文件。<br><strong>GIT_OBJECT_DIRECTORY</strong>：对象储存目录，.git&#x2F;objects 目录的位置。<br><strong>GIT_TEMPLATE_DIR</strong>:临时目录。<br><strong>GIT_TRACE_SETUP</strong>：显示 Git 发现的关于版本库和交互环境的信息<br><strong>PREFIX</strong>：系统级别的配置。</p><h4 id="关于提交"><a href="#关于提交" class="headerlink" title="关于提交"></a>关于提交</h4><p><strong>GIT_AUTHOR_NAME</strong> ：“author” 字段的可读名字。<br><strong>GIT_AUTHOR_EMAIL</strong>： “author” 字段的邮件。<br><strong>GIT_AUTHOR_DATE</strong> ： “author” 字段的时间戳。<br><strong>GIT_COMMITTER_NAME</strong> ： “committer” 字段的可读名字。<br><strong>GIT_COMMITTER_EMAIL</strong> ： “committer” 字段的邮件。<br><strong>GIT_COMMITTER_DATE</strong> ： “committer” 字段的时间戳。<br><strong>EMAIL</strong>：如果 user.email 没有配置， 就会用到此指定的邮件地址。</p><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><h4 id="关于参数"><a href="#关于参数" class="headerlink" title="关于参数"></a>关于参数</h4><p>在本文中，指令下方附带常用参数,本文用@p表示参数填入位置，参数可多选。参数前横杠规律：<br>单字母参数前一个横杠，如-a;<br>单词参数前两个横杠，如–option;<br>多单词参数最前面两横杠，单词间一横杠，如–on-contains。</p><h4 id="分享与更新类指令"><a href="#分享与更新类指令" class="headerlink" title="分享与更新类指令"></a>分享与更新类指令</h4><p><strong>git init @p</strong><br>初始化命令。在当前目录(如果指定了GIT_DIR将使用此目录)创建一个空的 Git 存储库或重新初始化现有的存储库，产生.git目录作为版本库。<br>-b &lt;分支名称&gt; - 为新创建的存储库中的初始分支使用指定的名称</p><p><strong>git clone [仓库url] @p [目录]</strong><br>将存储库内容克隆到本地目录，可以是远程主机的储存库。Git 支持 ssh、git、http 和 https 协议。</p><pre><code class="shell">git clone https://github.com/git/git/archive/v2.17.0.tar.gz</code></pre><p><strong>git add @p [文件或目录路径]</strong><br>将文件内容添加到暂存区中，会递归添加指定目录下所有文件，或是可以并排添加多个。添加”Documentation&#x2F;“支持正则匹配，如</p><pre><code class="shell">$ git add Documentation/\*.txt</code></pre><p>匹配目录及子目录下所有txt文件。不含’&#39;将不会搜索子目录。<br>-A 添加指定目录下所有文件，若未指定则当前目录。<br>-p 交互式地列出并询问前后版本差异，确认是否更改。（很细致）<br>-u</p><p><strong>git commit @p</strong><br>创建一个提交，记录对储存库的更改。这是对储存库的更新。<br>-m 参数后接字符串作为提交的信息(为什么做这次更改)。<br>-a会将没有使用git add的文件也提交到库。</p><p><strong>git config @p [配置项] [值]</strong><br>配置git使用的信息,如git config –global user.name “passacaglia”配置用户名。<br>–global 全局配置，而非仅当下储存库。</p><p><strong>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</strong><br>推送指令；提交本地仓库以更新远程仓库。</p><p><strong>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</strong><br>拉取指令。获取远程仓库的内容合并到本地。</p><blockquote><p>注：如果分支名相同，只需要写一个，省略冒号。</p></blockquote><h4 id="查看信息类指令"><a href="#查看信息类指令" class="headerlink" title="查看信息类指令"></a>查看信息类指令</h4><p><strong>git diff @p</strong><br>命令比较文件的不同，即比较文件在暂存区和工作区的差异。<br>–cached 查看已缓存的改动。<br>–stat 只显示摘要<br>HEAD 查看所有的改动</p><p><strong>git status @p</strong><br>查询仓库的当前状态。<br>-s 输出标记会有两列。</p><p><strong>git log @p</strong><br>查看历史记录，无参数时查看过去的提交信息和版本号。<br>–online 仅显示简洁版本。<br>–reverse 倒序显示日志。<br>–graph 拓扑图选项，可以看到何时出现分支和合并。<br>–author 只查看指定作者的日志。</p><h4 id="分支操作类指令"><a href="#分支操作类指令" class="headerlink" title="分支操作类指令"></a>分支操作类指令</h4><p><strong>git branch @p &lt;分支名&gt;</strong><br>列出、创造或删除分支。<br>–list：列出目前已有的分支，当前所处分支绿色高亮表示。<br>-d:删除指定的分支</p><p><strong>git checkout @p &lt;分支名&gt;</strong><br>切换分支或恢复工作树文件。</p><pre><code class="shell">git checkout master //切换到master分支</code></pre><p>-b &lt;分支名&gt; 创建一个本地分支并切换 </p><p><strong>git merge &lt;分支名&gt;</strong><br>从分支的分歧开始，将两个或多个开发历史合并在一起。将指定分支合并到HEAD指定的分支。</p><blockquote><p>快进合并(Fast-Forward)：通常的合并方式如图：<br><img src="https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/https://upload-1300382050.cos.ap-guangzhou.myqcloud.com/20220223225152.png" alt="20220223225152"><br>快进合并后原有的两条分支在逻辑上合成一条，就像快进了一样。比如topic合并到master后，只剩下D-E-F-G-H-A-B-C，但是HEAD位置仍在原位置。</p></blockquote><p><strong>git rebase</strong><br>快速合并分支，当从分支B融合到A上时，直接删除分支B，将分支B与A分歧的部分直接添加在A后面。</p><h4 id="补丁修改类指令"><a href="#补丁修改类指令" class="headerlink" title="补丁修改类指令"></a>补丁修改类指令</h4><p><strong>git revert &lt;版本号&gt;</strong><br>通过提交一个新的版本，在这个版本中撤消过去某个版本A所做的变化，来达到删除A的影响的目的。</p><blockquote><p><strong>注</strong>：&lt;版本号&gt;内容为HEAD时，指当前版本；HEAD^为上次,HEAD^^为上上次，以此类推。也可以用HEAD~n表示当前版本以前n个版本。</p></blockquote><p><strong>git reset @p &lt;版本号&gt;</strong><br>从当前位置A回退到之前的某个版本B。<br>–hard 回退到指定版本号，期间的版本全部丢弃。<br>–soft 回退到之前的指定版本。</p><blockquote><p><strong>注</strong>:由于回退后本地版本库可能会比远程库旧，下一次git push时需添加-f选项强制执行。</p></blockquote><p>常用的大概就这些，日后需要再添加。版本管理是一件值得做的事，一旦版本多了再管理就会很混乱。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
